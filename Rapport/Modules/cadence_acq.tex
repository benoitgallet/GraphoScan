Naturellement, différentes idées nous sont venues pour augmenter la cadence d'acquisition de la vidéo en stéréo. Nous les détaillons ici, même si par la suite cette liste sera sûrement étoffée. Le programme fonctionne suivant plusieurs étapes : Tout d'abord, une image est capturée à partir des deux caméras, puis les deux images sont encodées dans une vidéo. Une fois la capture finie, la vidéo est traitée afin de régler les problèmes de distorsion. Grâce à cette grande boucle qui capture les images deux par deux (une image par caméra), les vidéos finales commencent et terminent exactement au même moment, et permettent donc d'avoir exactement au même moment la feuille d'écriture filmée sous deux angles différents. La modélisation en 3D sous OpenGl est alors possible. La seule variable est que plus la cadence d'acquisition est élevée, plus il y aura de fps sur les vidéos finales, et plus la modélisation 3D de la plume sera précise. De plus, notre architecture et notre code doivent être assez robuste, pour que si un jour une troisième voire une quatrième caméra soient rajoutées, le nombre de fps ne redescende pas drastiquement.

\subsubsection{Programmation parallèle}

Grâce à la programmation parallèle, qu'elle soit au niveau du CPU avec de l'openmp ou des threads, ou au niveau du GPU avec CUDA, nous pensons pouvoir accélérer l'acquisition des images, et donc des fps sur les vidéos finales. Nous pensons regarder quelles parties peuvent être faites en parallèle, peut-être est-il possible d'uniquement récupérer une image tous les 3 centièmes de secondes (pour les 30 fps) dans le programme principal, et de faire tous les autres traitements dans des régions parallèles, avec par exemple un thread qui s'occupe d'ajouter la prochaine image à la vidéo, un autre thread qui enlève la distorsion de l'image, etc.

\subsubsection{Complexité}

Reprendre le code pour en examiner sa complexité est une autre piste envisagée pour augmenter les fps. Nous pensons séparer cette idée en deux étapes : Tout d'abord regarder la complexité de l'algorithme dans sa généralité, pour se rendre compte s'il y a problème ou non à ce niveau là, et voir les morceaux posant plus problème que le reste, puis faire des tests plus précisément sur ces parties pour voir précisément ce qui ne va pas. Une analyse légerement différente pourra être effectuée, avec des tests fontionnels calculant quelle partie prend le plus de temps. Ces tests sont très complémentaires des tests de complexité, à eux deux ils devraient mettre en exergue les problèmes principaux du code actuel.

\subsubsection{Modularité}

Outre cette analyse de la complexité, une mise au propre du code devra être effectuée. En effet, tout se trouve dans la fonction main, dans deux grandes boucles. Une partie de notre travail sera donc de modulariser cette fonction, de la séparer en plusieurs méthodes afin de gagner en clarté. La complexité ne devrait pas être touchée car nous rajoutons l'option \texttt{-O3} lors de la compilation afin d'avoir un code en une ligne. Ce nettoyage permettra de naviguer plus facilement dans le code, et de faciliter sa maintenance par la suite.

\subsubsection{Généralisation}

Sinon, le dernier axe sur lequel travailler sera la généralisation du nombre de caméra. Pour l'instant, tout dans le code est fait pour deux caméras, avec du code dupliqué deux fois pour chaque action. La généralisation pour n caméras sera facilitée par la modularisation du code, et permettra par la suite de rajouter une ou plusieurs caméras sans modification majeure du code, uniquement en changeant quelques \emph{\#define}.
