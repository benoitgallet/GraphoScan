\subsection{Acquisition}

\subsubsection{Acquisition stéréo et enregistrement des vidéos}

On assume le fait qu'il y ait n lignes et m colonnes dans une image. Nous proposons deux complexités, une borne min si on considère qu'un pixel de l'image se traite en temps $O(1)$, et une borne max si l'on considère que le pixel se traite en temps $O(3)$ à cause de ses caractéristiques RGB.

\textbf{Borne min}

Récupération de l'image brute (RetrieveBuffer) : $O(n*m)$

Conversion de l'image brute vers RGB (rawImage.Convert) : $O(n*m)$

Création de la matrice de l'image RGB (imageRGB=cv::Mat) : $O(n*m)$

Ecriture d'une image dans la vidéo (outputVideo.write) : $O(n*m)$

Ce qui nous donne un total de temps d'exécution en $O(4(n*m))$.

\textbf{Borne max}

Il suffit de multiplier par trois les valeurs précédentes, ce qui nous donne au total $O(12(n*m))$

\textbf{Analyse}

Nous pouvons donc en conclure que le temps d'exécution de l'algorithme C est :
$O(4(n*m)) \leq C \leq O(12(n*m))$

C'est-à-dire qu'il s'exécute globalement en temps linéaire en la taille de l'entrée. Cela dit, il faut l'exécuter à chaque tour de boucle (à chaque acquisition d'image), donc on pourrait dire que sa complexité serait alors de $O(n*m*f)$, f étant le nombre de frames que nous enregistrons. Evidemment, cela vaut pour la version parallèle du code, si on prend en compte la version séquentielle, il faut bien sûr multiplier cette complexité par le nombre de caméras que l'on a.

\subsubsection{Tracking}

De nombreux algorithmes de tracking existent, dans ce projet nous en utilisons plusieurs, tous fournis par OpenCV:
\begin{itemize}
\item KCF (High-Speed Tracking with Kernilized Correlation Filters) utilise les propriétés des matrices circulantes pour faire son tracking. (cf \cite{kernelized_correlation_filters})
\item TLD (Tracking Learning Detection) suit l'objet voulu image par image et grâce à une comparaison avec toutes les apparences observées réajuste le tracker de la cible. 
\item MIL (Multiple instance learning) crée et enrichie un classifieur pour sé\-pa\-rer l'objet suivi et le reste de l'image.
\item Boosting, comme MIL, utilise des classifieurs pour savoir où est l'objet et où sont les éléments extérieurs. 
\end{itemize}
Il y a également d'autres algorithmes mais nous n'avons pas eu le temps de les tester.
L'étudiant précédent a fait une comparaison entre l'algorithme KCF et TLD, à l'aide du comparatif des méthodes de tracking existantes, proposé par Joao F.Henriques et de quelques tests, il en est ressorti que KCF était plus efficace que TLD. 
Toutefois nous nous sommes également penché sur ce sujet. Pour savoir si un algorithme de tracking est plus efficace qu'un autre nous avons les avons comparés sur différents critères: 
\begin{itemize}
\item La perte ou non du tracker sur la cible.
\item La taille du tracker nécessaire pour avoir un tracking.
\item Le suivi de certains mouvements.
\item La rapidité d'exécution de l'algorithme.
\end{itemize}
Après avoir défini ces critères nous avons commencé les tests sur les mêmes vidéos à 30 fps. Ces tests ont donné des résultats complètement différents pour chaque algorithme.
KCF est l'algorithme le plus stable, le tracker suit parfaitement la cible tant que celle-ci n'effectue pas un mouvement trop rapide. C'est également celui qui a le temps d'exécution le plus rapide. Après analyse de son code (OpenSource), nous avons ressorti une complexité d'environ $O(n^{4})$, toutefois cette analyse fut rapide et nous n'avons pas eu le temps de l'approfondir.
Boosting et MIL, qui utilisent la même technique d'apprentissage et d'enrichissement de classifieurs, donnent les mêmes résultats. Le choix de la région d'interêt (ROI) a un impact significatif sur le tracking. L'utilisation d'un multi-tracker favorise l'analyse de l'image et ressort un tracking efficace, de plus la sélection d'une grande ROI n'a pas de réel impact.
TLD donne des résultats copmlètement différents selon la situation. Lors d'un tracking sur des mouvements simples, celui-ci est le moins efficace de tous. En effet, il recalcule la ROI à chaque frame ce qui est très coûteux et modifie le résultat final du tracking. Toutefois lors de mouvements rapides, qui ne sont pas gérés par les autres algorithmes, TLD arrive à retrouver  l'objet grâce à sa base de connaissance.
A partir de tous ces tests nous en avons conclu que le choix de l'algorithme dépend de l'objet que l'on veut suivre. Si celui-ci est simple à observer, KCF est le plus approprié, mais lorsqu'il commence à être plus compliqué à suivre, il est préférable de se tourner vers les autres algorithmes qui utilisent leurs bases de connaissances pour retrouver l'objet.
