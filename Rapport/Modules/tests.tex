Différents tests de validation ont été effectués tout au long du projet afin de s'assurer du bon fonctionnement de l'application. Ces tests pourront être refaits par la suite en décommentant les $\sharp$ define nécessaires, et pourront donc être réutilisés par des étudiants reprenant ce projet.

\subsection{Latence}

La latence est une caractéristique incontournable de notre projet, le client nous ayant précisé plusieurs fois que c'était très important qu'il y ait le moins de décalage possible entre les deux vidéos. Plus le décalage est grand et moins la reconstruction en 3D par la suite sera précise. Nous avons donc mesuré précisément le temps qui sépare deux frames dans le code. 

\begin{figure}[!h]
\centering
\includegraphics[width=\textwidth, height=10cm]{Modules/Picture/latence.png}
\caption{Latence}
\label{latence}
\end{figure}

Ce diagramme en bâton (Figure \ref{latence}) montre cette latence. Elle est plus importante avec le parallélisme qu'avec le programme séquentiel. Il faudra donc que le client pèse le pour et le contre sur la méthode qu'il préfère utiliser. Avec le parallelisme, le nombre de caméra pourra être augmenté (de façon raisonnable) sans chute de fps, car chaque coeur de la machine s'occupera d'une caméra particulière, par contre, la latence est plus importante(5 à 6 ms) . Avec la version séquentielle du code, la latence est plus que minime (1/2 millième de seconde environ), mais l'ajout d'une à plusieurs caméras fera chuter le nombre de fps.
De plus, la latence sera surement plus constante dans la région parallèle, car chaque thread s'occupant d'une caméra, celle-ci n'augmentera pas si on ajoute plus de caméras (dans la limite des coeurs disponibles sur la machine). Par contre, séquentiellement, comme on lance les acquisitions les unes après les autres, plus il y a de caméras, plus celles qui sont lancées en dernier auront de décalage avec la première.

\subsection{FPS}